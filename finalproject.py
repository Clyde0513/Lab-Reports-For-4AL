# -*- coding: utf-8 -*-
"""FinalProject

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_J5INAv_teDmHlKAPKoplml18v5OkQ9f
"""
# %%
# Importing required libraries
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as sp
import scipy.integrate as spint

# %%
"""**STEP 1: READING IN MOVING CART AND PENDULUM DATA FROM .txt FILES**


Reading in the following files:-

1) Moving cart - RUN 1 \\
2) Moving cart - RUN 2 \\
3) Moving cart - RUN 3 \\
4) Moving cart - RUN 4 \\
5) Moving cart - RUN 5 \\
6) Moving cart - RUN 6 \\

1) Pendulum - RUN 1 \\
2) Pendulum - RUN 2 \\
3) Pendulum - RUN 3 \\
4) Pendulum - RUN 4 \\
5) Pendulum - RUN 5 \\
6) Pendulum - RUN 6 \\

*Also entering values of $m1$ (moving cart) and $m2$ (pendulum) measured by weighing scale as well as length of pendulum $l$ measured by ruler
"""
# %%
# Reading in all the moving cart data into arrays
read_in_firstMovingCart = np.loadtxt("first_movingCart.txt", delimiter=";")
read_in_secondMovingCart = np.loadtxt("second_movingCart.txt", delimiter=";")
read_in_thirdMovingCart = np.loadtxt("third_movingCart.txt", delimiter=";")
read_in_fourthMovingCart = np.loadtxt("fourth_movingCart.txt", delimiter=";")
read_in_fifthMovingCart = np.loadtxt("fifth_movingCart.txt", delimiter=";")
read_in_sixthMovingCart = np.loadtxt("sixth_movingCart.txt", delimiter=";")

# Reading in all the pendulum data into arrays
read_in_firstPendulum = np.loadtxt("first_Pendulum.txt", delimiter=",")
read_in_secondPendulum = np.loadtxt("second_Pendulum.txt", delimiter=",")
read_in_thirdPendulum = np.loadtxt("third_Pendulum.txt", delimiter=",")
read_in_fourthPendulum = np.loadtxt("fourth_Pendulum.txt", delimiter=",")
read_in_fifthPendulum = np.loadtxt("fifth_Pendulum.txt", delimiter=",")
read_in_sixthPendulum = np.loadtxt("sixth_Pendulum.txt", delimiter=",")

# Assigning the time and distance to variables for the Moving Cart m1 (Runs 1-4)

firstMovingCart_time = read_in_firstMovingCart[:, 0] / 1000
firstMovingCart_dist = read_in_firstMovingCart[:, 1] / 100

"""secondMovingCart_time = read_in_secondMovingCart[:,0] / 1000
secondMovingCart_dist = read_in_secondMovingCart[:,1] / 100
"""
thirdMovingCart_time = read_in_thirdMovingCart[:, 0] / 1000
thirdMovingCart_dist = read_in_thirdMovingCart[:, 1] / 100
"""
fourthMovingCart_time = read_in_fourthMovingCart[:,0] / 1000
fourthMovingCart_dist = read_in_fourthMovingCart[:,1] / 100
"""
fifthMovingCart_time = read_in_fifthMovingCart[:, 0] / 1000
fifthMovingCart_dist = read_in_fifthMovingCart[:, 1] / 100

sixthMovingCart_time = read_in_sixthMovingCart[:, 0] / 1000
sixthMovingCart_dist = read_in_sixthMovingCart[:, 1] / 100

# Assigning the time, distance, and accelerometer data to variables for the Pendulum m2 (Runs 1-4)
firstPendulum_time = read_in_firstPendulum[:, 0] / 1000
firstPendulum_dist = read_in_firstPendulum[:, 1] / 100
firstPendulum_ax = read_in_firstPendulum[:, 2]
firstPendulum_ay = read_in_firstPendulum[:, 3]

"""
secondPendulum_time = read_in_secondPendulum[:,0] / 1000
secondPendulum_dist = read_in_secondPendulum[:,1] / 100
secondPendulum_ax = read_in_secondPendulum[:,2]
secondPendulum_ay = read_in_secondPendulum[:,3]
"""

thirdPendulum_time = read_in_thirdPendulum[:, 0] / 1000
thirdPendulum_dist = read_in_thirdPendulum[:, 1] / 100
thirdPendulum_ax = read_in_thirdPendulum[:, 2]
thirdPendulum_ay = read_in_thirdPendulum[:, 3]

"""
fourthPendulum_time = read_in_fourthPendulum[:,0] / 1000
fourthPendulum_dist = read_in_fourthPendulum[:,1] / 100
fourthPendulum_ax = read_in_fourthPendulum[:,2]
fourthPendulum_ay = read_in_fourthPendulum[:,3]
"""

fifthPendulum_time = read_in_fifthPendulum[:, 0] / 1000
fifthPendulum_dist = read_in_fifthPendulum[:, 1] / 100
fifthPendulum_ax = read_in_fifthPendulum[:, 2]
fifthPendulum_ay = read_in_fifthPendulum[:, 3]


sixthPendulum_time = read_in_sixthPendulum[:, 0] / 1000
sixthPendulum_dist = read_in_sixthPendulum[:, 1] / 100
sixthPendulum_ax = read_in_sixthPendulum[:, 2]
sixthPendulum_ay = read_in_sixthPendulum[:, 3]

# Making lists to manage run data
MovingCart_time = [
    firstMovingCart_time,
    thirdMovingCart_time,
    fifthMovingCart_time,
    sixthMovingCart_time,
]
MovingCart_dist = [
    firstMovingCart_dist,
    thirdMovingCart_dist,
    fifthMovingCart_dist,
    sixthMovingCart_dist,
]
Pendulum_time = [
    firstPendulum_time,
    thirdPendulum_time,
    fifthPendulum_time,
    sixthPendulum_time,
]
Pendulum_dist = [
    firstPendulum_dist,
    thirdPendulum_dist,
    fifthPendulum_dist,
    sixthPendulum_dist,
]
Pendulum_ax = [firstPendulum_ax, thirdPendulum_ax, fifthPendulum_ax, sixthPendulum_ax]
Pendulum_ay = [firstPendulum_ay, thirdPendulum_ay, fifthPendulum_ay, sixthPendulum_ay]

# Entering weighing scale values for m1 and m2 along with errors
m1 = 430 / 1000  # 430 g
m2 = 233 / 1000  # 233 g
delta_m1 = 0.5 / 1000  # minimum value of weighing scale was 1 g
delta_m2 = 0.5 / 1000
l = 0.442  # 20 cm
delta_l = 0.0005  # 0.1cm/2
# %%
"""**STEP 2: ANALYZING MOVING CART DATA TO OBTAIN $u1_{c1}$ (initial velocity of moving cart $m1$) AND $v1_{c1}$ (final velocity of moving cart $m1$) FOR COLLISION 1 AND $v1_{c2}$ (final velocity of moving cart $m1$) FOR COLLISION 2.**"""
# %%
# Plotting distance vs. time for Moving Cart m1 (Runs 1-4)
for i in range(len(MovingCart_time)):  # len=4 because 4 runs
    plt.plot(MovingCart_time[i], MovingCart_dist[i], label="Moving Cart (m1)")
    plt.title("Moving Cart: Distance vs. Time (Run " + str(i + 1) + ")")
    plt.xlabel("Time (s)")
    plt.ylabel("Distance (m)")
    plt.legend()
    plt.show()

# Plotting distance vs. array index for Moving Cart m1 (Runs 1-4)
for i in range(len(MovingCart_time)):  # len=6 because 6 runs
    array_indices = np.arange(len(MovingCart_dist[i]))
    plt.scatter(array_indices, MovingCart_dist[i])
    plt.title("Moving Cart: Distance vs. Array Index (Run " + str(i + 1) + ")")
    plt.xlabel("Array Index")
    plt.ylabel("Distance (m)")
    plt.show()
# %%
# Making pre-collision and post-collision cut offs from the above graphs for Moving Cart m1 (Runs 1-6)
# %%
# Start and End index of the pre-collision data (Runs 1-6)
firstMovingCart_dist_pre = MovingCart_dist[0][0:18]
firstMovingCart_time_pre = MovingCart_time[0][
    0:18
]  # The indices for the time are going to be same as that of the position


thirdMovingCart_dist_pre = MovingCart_dist[1][0:8]
thirdMovingCart_time_pre = MovingCart_time[1][0:8]


fifthMovingCart_dist_pre = MovingCart_dist[2][0:8]
fifthMovingCart_time_pre = MovingCart_time[2][0:8]

sixthMovingCart_dist_pre = MovingCart_dist[3][0:8]
sixthMovingCart_time_pre = MovingCart_time[3][0:8]

# Start and End index of the post-collision data (Runs 1-6)
firstMovingCart_dist_pos = MovingCart_dist[0][18:39]
firstMovingCart_time_pos = MovingCart_time[0][
    18:39
]  # The indices for the time are going to be same as that of the position
dist_trav_d1 = MovingCart_dist[0][39] - MovingCart_dist[0][18]


thirdMovingCart_dist_pos = MovingCart_dist[1][8:25]
thirdMovingCart_time_pos = MovingCart_time[1][8:25]
dist_trav_d3 = MovingCart_dist[1][25] - MovingCart_dist[1][8]


fifthMovingCart_dist_pos = MovingCart_dist[2][8:24]
fifthMovingCart_time_pos = MovingCart_time[2][8:24]
dist_trav_d5 = MovingCart_dist[2][24] - MovingCart_dist[2][8]

sixthMovingCart_dist_pos = MovingCart_dist[3][8:22]
sixthMovingCart_time_pos = MovingCart_time[3][8:22]
dist_trav_d6 = MovingCart_dist[3][22] - MovingCart_dist[3][8]

# Start and End index of the post-collision 2 data (Runs 1-6)
firstMovingCart_dist_pos2 = MovingCart_dist[0][39:58]
firstMovingCart_time_pos2 = MovingCart_time[0][
    39:58
]  # The indices for the time are going to be same as that of the position


thirdMovingCart_dist_pos2 = MovingCart_dist[1][25:48]
thirdMovingCart_time_pos2 = MovingCart_time[1][25:48]


fifthMovingCart_dist_pos2 = MovingCart_dist[2][24:48]
fifthMovingCart_time_pos2 = MovingCart_time[2][24:48]

sixthMovingCart_dist_pos2 = MovingCart_dist[3][22:38]
sixthMovingCart_time_pos2 = MovingCart_time[3][22:38]

# Making lists to manage cut-off data
MovingCart_time_pre = [
    firstMovingCart_time_pre,
    thirdMovingCart_time_pre,
    fifthMovingCart_time_pre,
    sixthMovingCart_time_pre,
]
MovingCart_dist_pre = [
    firstMovingCart_dist_pre,
    thirdMovingCart_dist_pre,
    fifthMovingCart_dist_pre,
    sixthMovingCart_dist_pre,
]
MovingCart_time_pos = [
    firstMovingCart_time_pos,
    thirdMovingCart_time_pos,
    fifthMovingCart_time_pos,
    sixthMovingCart_time_pos,
]
MovingCart_dist_pos = [
    firstMovingCart_dist_pos,
    thirdMovingCart_dist_pos,
    fifthMovingCart_dist_pos,
    sixthMovingCart_dist_pos,
]
MovingCart_time_pos2 = [
    firstMovingCart_time_pos2,
    thirdMovingCart_time_pos2,
    fifthMovingCart_time_pos2,
    sixthMovingCart_time_pos2,
]
MovingCart_dist_pos2 = [
    firstMovingCart_dist_pos2,
    thirdMovingCart_dist_pos2,
    fifthMovingCart_dist_pos2,
    sixthMovingCart_dist_pos2,
]
# %%
# Using polyfit to find the best fit lines for distance vs. time and extracting velocity of Moving Cart m1 using slope of best fit
# %%
u1_list = []
delta_u1_list = []
for i in range(len(MovingCart_time_pre)):
    MovingCart_coeff_pre, MovingCart_cov_pre = np.polyfit(
        MovingCart_time_pre[i], MovingCart_dist_pre[i], 1, cov=True
    )  # The slope of this curve is the velocity pre-collision
    plt.scatter(
        MovingCart_time_pre[i], MovingCart_dist_pre[i], c="red", label="Raw Data"
    )
    plt.plot(
        MovingCart_time_pre[i],
        MovingCart_coeff_pre[0] * MovingCart_time_pre[i] + MovingCart_coeff_pre[1],
        label="Best-fit",
    )
    plt.title("Moving Cart Pre-Collision 1 Distance vs. Time Best-Fit: Run 1")
    plt.legend()
    plt.xlabel("Time (s)")
    plt.ylabel("Distance (m)")
    plt.show()
    u1 = MovingCart_coeff_pre[0]
    delta_u1 = np.sqrt(MovingCart_cov_pre[0, 0])
    u1_list.append(u1)
    delta_u1_list.append(delta_u1)

# Repeat the process to find the velocity and its error post-collision
v1_list = []
delta_v1_list = []
for i in range(len(MovingCart_time_pos)):
    MovingCart_coeff_pos, MovingCart_cov_pos = np.polyfit(
        MovingCart_time_pos[i], MovingCart_dist_pos[i], 1, cov=True
    )  # The slope of this curve is the velocity post-collision
    plt.scatter(MovingCart_time_pos[i], MovingCart_dist_pos[i], label="Raw Data")
    plt.plot(
        MovingCart_time_pos[i],
        MovingCart_coeff_pos[0] * MovingCart_time_pos[i] + MovingCart_coeff_pos[1],
        c="red",
        label="Best-fit",
    )
    plt.title("Moving Cart Post-Collision 1 Distance vs. Time Best-Fit")
    plt.legend()
    plt.xlabel("Time (s)")
    plt.ylabel("Distance (m)")
    plt.show()
    v1 = MovingCart_coeff_pos[0]
    delta_v1 = np.sqrt(MovingCart_cov_pos[0, 0])
    v1_list.append(v1)
    delta_v1_list.append(delta_v1)

# Repeat the process to find the velocity and its error post-collision 2
c2_v1_list = []
delta_c2_v1_list = []
for i in range(len(MovingCart_time_pos2)):
    MovingCart_coeff_pos2, MovingCart_cov_pos2 = np.polyfit(
        MovingCart_time_pos2[i], MovingCart_dist_pos2[i], 1, cov=True
    )  # The slope of this curve is the velocity post-collision
    plt.scatter(MovingCart_time_pos2[i], MovingCart_dist_pos2[i], label="Raw Data")
    plt.plot(
        MovingCart_time_pos2[i],
        MovingCart_coeff_pos2[0] * MovingCart_time_pos2[i] + MovingCart_coeff_pos2[1],
        c="red",
        label="Best-fit",
    )
    plt.title("Moving Cart Post-Collision 2 Distance vs. Time Best-Fit")
    plt.legend()
    plt.xlabel("Time (s)")
    plt.ylabel("Distance (m)")
    plt.show()
    c2_v1 = MovingCart_coeff_pos2[0]
    delta_c2_v1 = np.sqrt(MovingCart_cov_pos2[0, 0])
    c2_v1_list.append(c2_v1)
    delta_c2_v1_list.append(delta_c2_v1)

for i in range(len(MovingCart_time_pre)):
    print(
        "u1 = "
        + str(u1_list[i])
        + " +- "
        + str(delta_u1_list[i])
        + " m/s (Run "
        + str(i + 1)
        + ")"
    )
for i in range(len(MovingCart_time_pos)):
    print(
        "v1 = "
        + str(v1_list[i])
        + " +- "
        + str(delta_v1_list[i])
        + " m/s (Run "
        + str(i + 1)
        + ")"
    )
for i in range(len(MovingCart_time_pos2)):
    print(
        "c2_v1 = "
        + str(c2_v1_list[i])
        + " +- "
        + str(delta_c2_v1_list[i])
        + " m/s (Run "
        + str(i + 1)
        + ")"
    )  # experimental v_cf
# %%
"""**STEP 3: CALIBRATION FOR PENDULUM ACCELEROMETER DATA**


"""
# %%
# Calibration
read_in_array_x = np.loadtxt("x_calibration.txt", delimiter=",")
x_calibration_ax = read_in_array_x[:, 2]
x_calibration_ay = read_in_array_x[:, 3]
x_calibration_az = read_in_array_x[:, 4]

read_in_array_y = np.loadtxt("y_calibration.txt", delimiter=",")
y_calibration_ax = read_in_array_y[:, 2]
y_calibration_ay = read_in_array_y[:, 3]
y_calibration_az = read_in_array_y[:, 4]

read_in_array_z = np.loadtxt("z_calibration.txt", delimiter=",")
z_calibration_ax = read_in_array_z[:, 2]
z_calibration_ay = read_in_array_z[:, 3]
z_calibration_az = read_in_array_z[:, 4]

x_calibration_true_ax = np.ones(len(x_calibration_ax)) * -9.81
x_calibration_true_ay = np.zeros(len(x_calibration_ay))
x_calibration_true_az = np.zeros(len(x_calibration_ay))

y_calibration_true_ax = np.zeros(len(y_calibration_ax))
y_calibration_true_ay = np.ones(len(y_calibration_ay)) * -9.81
y_calibration_true_az = np.zeros(len(y_calibration_ay))

z_calibration_true_ax = np.zeros(len(z_calibration_ax))
z_calibration_true_ay = np.zeros(len(z_calibration_ay))
z_calibration_true_az = np.ones(len(z_calibration_ay)) * -9.81

plt.scatter(x_calibration_ax, x_calibration_true_ax, c="red")
plt.scatter(y_calibration_ax, y_calibration_true_ax, c="blue")
plt.scatter(z_calibration_ax, z_calibration_true_ax, c="green")
plt.title("True acceleration vs. Accelerometer output in the x direction")
plt.xlabel("Accelerometer (units)")  # accelerometer output has unknown units
plt.ylabel("Acceleration m/s^2")
plt.show()

plt.scatter(x_calibration_ay, x_calibration_true_ay, c="red")
plt.scatter(y_calibration_ay, y_calibration_true_ay, c="blue")
plt.scatter(z_calibration_ay, z_calibration_true_ay, c="green")
plt.title("True acceleration vs. Accelerometer output in the y direction")
plt.xlabel("Accelerometer (units)")
plt.ylabel("Acceleration m/s^2")
plt.show()

plt.scatter(x_calibration_az, x_calibration_true_az, c="red")
plt.scatter(y_calibration_az, y_calibration_true_az, c="blue")
plt.scatter(z_calibration_az, z_calibration_true_az, c="green")
plt.title("True acceleration vs. Accelerometer output in the z direction")
plt.xlabel("Accelerometer (units)")
plt.ylabel("Acceleration m/s^2")
# %%
# Calibration continued
# %%
output_ax = np.append(x_calibration_ax, np.append(y_calibration_ax, z_calibration_ax))
true_ax = np.append(
    x_calibration_true_ax, np.append(y_calibration_true_ax, z_calibration_true_ax)
)

output_ay = np.append(x_calibration_ay, np.append(y_calibration_ay, z_calibration_ay))
true_ay = np.append(
    x_calibration_true_ay, np.append(y_calibration_true_ay, z_calibration_true_ay)
)

output_az = np.append(x_calibration_az, np.append(y_calibration_az, z_calibration_az))
true_az = np.append(
    x_calibration_true_az, np.append(y_calibration_true_az, z_calibration_true_az)
)

# Use np.polyfit() to extract the fit coefficients and uncertainties for the x and y directions
coeff_x, cov_x = np.polyfit(output_ax, true_ax, 1, cov=True)
coeff_y, cov_y = np.polyfit(output_ay, true_ay, 1, cov=True)
coeff_z, cov_z = np.polyfit(output_az, true_az, 1, cov=True)

print(coeff_x)
print(cov_x)
print("\n")
print(coeff_y)
print(cov_y)
print("\n")
print(coeff_z)
print(cov_z)


# Define a function to convert the accelerometer output in the x direction to the true acceleration
def output_to_accel_x(output):
    # acceleration = slope*analog_output + intercept
    accel = coeff_x[0] * output + coeff_x[1]
    return accel


# Define a function to convert the accelerometer output in the y direction to the true acceleration
def output_to_accel_y(output):
    # acceleration = slope*analog_output + intercept
    accel = coeff_y[0] * output + coeff_y[1]
    return accel


# Define a function to convert the accelerometer output in the z direction to the true acceleration
def output_to_accel_z(output):
    # acceleration = slope*analog_output + intercept
    accel = coeff_z[0] * output + coeff_z[1]
    return accel


# Relative acceleration = Total acceleration - (-Acceleration due to gravity (g))
def rel_acceleration_in_x(output):
    return output_to_accel_x(output) + 9.81


def rel_acceleration_in_y(output):
    return output_to_accel_y(output) + 9.81


def rel_acceleration_in_z(output):
    return output_to_accel_z(output) + 9.81


# %%
"""**STEP 4: ANALYZING ACCELEROMETER DATA TO GET $v_{pf}$ and IMPULSE**"""
# %%
for i in range(len(Pendulum_time)):  # len=6 because 6 runs
    plt.plot(
        Pendulum_time[i], rel_acceleration_in_y(Pendulum_ay[i]), label="Pendulum (m2)"
    )
    plt.title("Pendulum: Distance vs. Time (Run " + str(i + 1) + ")")
    plt.xlabel("Time (s)")
    plt.ylabel("Acceleration")
    plt.legend()
    plt.show()


for i in range(len(Pendulum_time)):  # len=6 because 6 runs
    array_indices = np.arange(len(rel_acceleration_in_y(Pendulum_ay[i])))
    plt.plot(array_indices, rel_acceleration_in_y(Pendulum_ay[i]))
    plt.title(
        "Pendulum: Accelererometer output vs. Array Index (Run " + str(i + 1) + ")"
    )
    plt.xlabel("Array Index")
    plt.ylabel("Acceleration (m/s^2)")
    plt.show()
# %%
# Impulse calculation (not an accurate way of solving the final velocity of the 2nd pendulum cart )
# %%
# print(rel_acceleration_in_y(Pendulum_ay[5]))
y1_c1 = m2 * rel_acceleration_in_y(Pendulum_ay[i][10:12])
y1_c2 = m2 * rel_acceleration_in_y(Pendulum_ay[i][26:29])
y3_c1 = m2 * rel_acceleration_in_y(Pendulum_ay[i][5:10])
y3_c2 = m2 * rel_acceleration_in_y(Pendulum_ay[i][19:24])
y5_c1 = m2 * rel_acceleration_in_y(Pendulum_ay[i][7:10])
y5_c2 = m2 * rel_acceleration_in_y(Pendulum_ay[i][20:27])
y6_c1 = m2 * rel_acceleration_in_y(Pendulum_ay[i][5:8])
y6_c2 = m2 * rel_acceleration_in_y(Pendulum_ay[i][18:25])

impulse1_c1 = spint.simpson(y1_c1, dx=0.1)
print("impulse1_c1 =", impulse1_c1)
impulse1_c2 = spint.simpson(y1_c2, dx=0.2)
print("impulse1_c2 =", impulse1_c2)
impulse3_c1 = spint.simpson(y3_c1, dx=0.2)
print("impulse3_c1 =", impulse3_c1)
impulse3_c2 = spint.simpson(y3_c2, dx=0.3)
print("impulse3_c2 =", impulse3_c2)
impulse5_c1 = spint.simpson(y5_c1, dx=0.15)
print("impulse5_c1 =", impulse5_c1)
impulse5_c2 = spint.simpson(y5_c2, dx=0.3)
print("impulse5_c2 =", impulse5_c2)
impulse6_c1 = spint.simpson(y6_c1, dx=0.15)
print("impulse6_c1 =", impulse6_c1)
impulse6_c2 = spint.simpson(y6_c2, dx=0.35)
print("impulse6_c2 =", impulse6_c2)

v_cf_imp1 = (m1 * u1_list[0] - impulse1_c1 - impulse1_c2) / m1
v_cf_imp3 = (m1 * u1_list[1] - impulse3_c1 - impulse3_c2) / m1
v_cf_imp5 = (m1 * u1_list[2] - impulse5_c1 - impulse5_c2) / m1
v_cf_imp6 = (m1 * u1_list[3] - impulse6_c1 - impulse6_c2) / m1
print(v_cf_imp1)
print(v_cf_imp3)
print(v_cf_imp5)
print(v_cf_imp6)
# %%
# Non impulse calculation from here on
# %%
firstPendulum_dist_osc = Pendulum_dist[0][38:70]
firstPendulum_time_osc = Pendulum_time[0][
    38:70
]  # The indices for the time are going to be same as that of the position
firstPendulum_ay_osc = Pendulum_ay[0][38:70]

thirdPendulum_dist_osc = Pendulum_dist[1][32:54]
thirdPendulum_time_osc = Pendulum_time[1][32:54]
thirdPendulum_ay_osc = Pendulum_ay[1][32:54]

fifthPendulum_dist_osc = Pendulum_dist[2][45:74]
fifthPendulum_time_osc = Pendulum_time[2][45:74]
fifthPendulum_ay_osc = Pendulum_ay[2][45:74]

sixthPendulum_dist_osc = Pendulum_dist[3][32:61]
sixthPendulum_time_osc = Pendulum_time[3][32:61]
sixthPendulum_ay_osc = Pendulum_ay[3][32:61]

Pend_dist = [
    firstPendulum_dist_osc,
    thirdPendulum_dist_osc,
    fifthPendulum_dist_osc,
    sixthPendulum_dist_osc,
]
Pend_time = [
    firstPendulum_time_osc,
    thirdPendulum_time_osc,
    fifthPendulum_time_osc,
    sixthPendulum_time_osc,
]
Pend_ay = [
    firstPendulum_ay_osc,
    thirdPendulum_ay_osc,
    fifthPendulum_ay_osc,
    sixthPendulum_ay_osc,
]
# %%
# %%
for i in range(len(Pend_time)):
    plt.plot(Pend_time[i], rel_acceleration_in_y(Pend_ay[i]))
    plt.title(
        "Pendulum: Accelererometer output vs. Time Refined (Run " + str(i + 1) + ")"
    )
    plt.xlabel("Time (s)")
    plt.ylabel("Acceleration (m/s^2)")
    plt.show()

# Centering at zero

accel = [
    rel_acceleration_in_y(Pend_ay[0]) - 10.81,
    rel_acceleration_in_y(Pend_ay[1]) - 10.4,
    rel_acceleration_in_y(Pend_ay[2]) - 10.49,
    rel_acceleration_in_y(Pend_ay[3]) - 10.64,
]
for i in range(len(Pend_time)):
    plt.plot(Pend_time[i], accel[i])
    plt.title(
        "Pendulum: Accelererometer output vs. Time Refined (Run " + str(i + 1) + ")"
    )
    plt.xlabel("Time (s)")
    plt.ylabel("Acceleration (m/s^2)")
    plt.show()
# %%


# %%
def sin_fit_function(time, amplitude, angular_frequency, phase, offset):
    height = amplitude * np.sin(angular_frequency * time + phase) + offset
    return height


# Make guess parameters
# Guess Amplitude list
guess_amplitude_list = [0.48, 0.5, 0.36, 0.54]
# Guess Angular Frequency
guess_angular_frequency_list = [
    (2 * np.pi) / (1.1 / 4),
    (2 * np.pi) / (0.8 / 3),
    (2 * np.pi) / (1.1 / 4),
    (2 * np.pi) / (1 / 4),
]
# Guess Phase = 0
guess_phase_list = [0, 0, 0, 0]
# Guess Offset
guess_offset_list = [0, 0, 0, 0]

for i in range(4):
    guess_parameters = [
        guess_amplitude_list[i],
        guess_angular_frequency_list[i],
        guess_phase_list[i],
        guess_offset_list[i],
    ]
    theoretical_guess_function = sin_fit_function(Pend_time[i], *guess_parameters)
    plt.plot(
        Pend_time[i],
        theoretical_guess_function,
        color="green",
        label="Guessed sine function",
    )
    plt.plot(Pend_time[i], accel[i], label="Ultrasound data")
    # Title, axis labels, legend
    plt.xlabel("Time (s)")
    plt.ylabel("Acceleration (m)")
    plt.title("Accelerometer data with the initial guess sin function")
    plt.legend()
    plt.show()
# %%
# Use curve_fit to get the best-fit parameters

# %%
fitted_acceleration_list = []
optimal_params_list = []
cov_list = []
for i in range(4):
    guess_parameters = [
        guess_amplitude_list[i],
        guess_angular_frequency_list[i],
        guess_phase_list[i],
        guess_offset_list[i],
    ]
    optimal_params, param_covariance = sp.curve_fit(
        sin_fit_function, Pend_time[i], accel[i], p0=guess_parameters
    )
    print("Best Amplitude: " + str(optimal_params[0]))
    print("Best Angular Frequency: " + str(optimal_params[1]))
    print("Best Phase: " + str(optimal_params[2]))
    print("Best Offset: " + str(optimal_params[3]))
    fitted_function = sin_fit_function(Pend_time[i], *optimal_params)
    fitted_acceleration_list.append(fitted_function)
    optimal_params_list.append(optimal_params)
    cov_list.append(param_covariance)
    plt.plot(Pend_time[i], fitted_function, color="green", label="Best fit function")
    plt.plot(Pend_time[i], accel[i], label="Ultrasound data")
    # Title, axis labels, legend
    plt.xlabel("Time (s)")
    plt.ylabel("Acceleration (m/s^2)")
    plt.legend()
    plt.title("Accelerometer data with the best fit sin function")
    plt.show()
# %%
# Calculating error for fitted acceleration

# %%
delta_ay_list = []
for i in range(4):
    ay = fitted_acceleration_list[i]
    k01 = optimal_params_list[i][1] * Pend_time[i]
    delta_k01 = np.abs(k01) * (
        (np.sqrt(cov_list[i][1, 1])) / np.abs(optimal_params_list[i][1])
    )
    k02 = k01 + optimal_params_list[i][2]
    delta_k02 = np.sqrt((delta_k01) ** 2 + (np.sqrt(cov_list[i][2, 2])) ** 2)
    k03 = np.sin(k02)
    delta_k03 = delta_k02 * np.cos(k02)
    k = optimal_params_list[i][0] * k03
    delta_k = np.abs(k) * np.sqrt(
        ((np.sqrt(cov_list[i][0, 0])) / optimal_params_list[i][0]) ** 2
        + (delta_k03 / k03) ** 2
    )
    delta_ay = np.sqrt((delta_k) ** 2 + np.sqrt((cov_list[i][3, 3])) ** 2)
    delta_ay_list.append(delta_ay)
print(delta_ay_list)
# %%
# Plotting tilt angle vs. time
# %%
max_theta_list = []
theta_index = []
delta_theta_list = []
theta_list = []
for i in range(4):
    alpha = fitted_acceleration_list[i] / 9.81
    delta_alpha = np.abs(alpha) * (
        delta_ay_list[i] / np.abs(fitted_acceleration_list[i])
    )
    theta = np.arcsin(fitted_acceleration_list[i] / 9.81)
    theta_list.append(theta)
    delta_theta = delta_alpha / (np.sqrt(9.81**2 - alpha**2))
    for j in range(len(theta)):
        if theta[j] == np.max(theta):
            theta_index.append(j)
            delta_theta_list.append(delta_theta[j])
    max_theta_list.append(np.max(theta))
    plt.plot(Pend_time[i], theta * 57.2958, color="green", label="Tilt Angle")
    plt.plot(Pend_time[i], theta * 57.2958, color="green", label="Tilt Angle")
    # Title, axis labels, legend
    plt.xlabel("Time (s)")
    plt.ylabel("Angle (degrees)")
    plt.legend()
    plt.title("Tilt Angle vs Time")
    plt.show()

print(theta_index)
print(max_theta_list)
print(delta_theta_list)
# %%

# %%
# Theoretical differentiation of theta
ind_list = [29, 13, 24, 22]  # indices right after 2nd collision

ang_v_list = []
for i in range(4):
    angular_v = (
        (1 / 9.81)
        * (1 / np.sqrt(1 - (fitted_acceleration_list[i] / 9.81) ** 2))
        * (
            optimal_params_list[i][0]
            * optimal_params_list[i][1]
            * np.cos(
                optimal_params_list[i][1] * Pend_time[i] + optimal_params_list[i][2]
            )
        )
    )
    ang_v_list.append(
        angular_v[ind_list[i]]
    )  # index is from when collision just occurs

# Theoretical prediction calculation
l = 0.44  # cm


def cospostcol(d):
    return np.sqrt(l**2 - d**2) / l


# RUN 1
v2_1 = (m1 / m2) * (u1_list[0] - v1_list[0])
v_cf1 = v1_list[0] - (m2 / m1) * (
    (np.sqrt(v2_1**2 - 2 * 9.81 * (l - l * cospostcol(dist_trav_d1))))
    * cospostcol(dist_trav_d1)
    - l * ang_v_list[0] * cospostcol(dist_trav_d1)
)

# RUN 3
v2_3 = (m1 / m2) * (u1_list[1] - v1_list[1])
v_cf3 = v1_list[1] - (m2 / m1) * (
    (np.sqrt(v2_1**2 - 2 * 9.81 * (l - l * cospostcol(dist_trav_d3))))
    * cospostcol(dist_trav_d3)
    - l * ang_v_list[1] * cospostcol(dist_trav_d3)
)

# RUN 5
v2_5 = (m1 / m2) * (u1_list[2] - v1_list[2])
v_cf5 = v1_list[2] - (m2 / m1) * (
    (np.sqrt(v2_1**2 - 2 * 9.81 * (l - l * cospostcol(dist_trav_d5))))
    * cospostcol(dist_trav_d5)
    - l * ang_v_list[2] * cospostcol(dist_trav_d5)
)

# RUN 6
v2_6 = (m1 / m2) * (u1_list[3] - v1_list[3])
v_cf6 = v1_list[3] - (m2 / m1) * (
    (np.sqrt(v2_1**2 - 2 * 9.81 * (l - l * cospostcol(dist_trav_d6))))
    * cospostcol(dist_trav_d6)
    - l * ang_v_list[3] * cospostcol(dist_trav_d6)
)

# print('Velocity of pendulum after collision 1 RUN1 ' + str(v2_1))
print("Velocity of cart after collision 2 RUN1 " + str(v_cf1))
# print('Velocity of pendulum after collision 1 RUN3 ' + str(v2_3))
print("Velocity of cart after collision 2 RUN3 " + str(v_cf3))
# print('Velocity of pendulum after collision 1 RUN5 ' + str(v2_5))
print("Velocity of cart after collision 2 RUN5 " + str(v_cf5))
# print('Velocity of pendulum after collision 1 RUN6 ' + str(v2_6))
print("Velocity of cart after collision 2 RUN6 " + str(v_cf6))
# %%

"""
End of the actual work: below is just trial and run of the 
actual final Physics of the conversation of momentum and energy on a pendulum w/ a cart
"""


"""
c2_v1 = -0.13409807412091052 +- 0.007238752562258019 m/s (Run 1)
c2_v1 = -0.12290807278227915 +- 0.004531890119341168 m/s (Run 3)
c2_v1 = -0.0785391973361569 +- 0.003239888189722608 m/s (Run 5)
c2_v1 = -0.08796842697495309 +- 0.0038423612878484164 m/s (Run 6)
"""

"""**END OF FAIR FINAL**"""

# Plotting distance vs. time for Pendulum m2 (Runs 1-6)
for i in range(len(Pendulum_time)):  # len=6 because 6 runs
    plt.plot(Pendulum_time[i], Pendulum_dist[i], label="Pendulum (m2)")
    plt.title("Pendulum: Distance vs. Time (Run " + str(i + 1) + ")")
    plt.xlabel("Time (s)")
    plt.ylabel("Distance (m)")
    plt.legend()
    plt.show()

# Plotting distance vs. array index for Pendulum m2 (Runs 1-6)
for i in range(len(Pendulum_time)):  # len=6 because 6 runs
    array_indices = np.arange(len(Pendulum_dist[i]))
    plt.scatter(array_indices, Pendulum_dist[i])
    plt.title("Pendulum: Distance vs. Array Index (Run " + str(i + 1) + ")")
    plt.xlabel("Array Index")
    plt.ylabel("Distance (m)")
    plt.show()

"""**END OF FAIR (actual)**"""

# Making maximum height cut offs from the above graphs for Pendulum Cart m2 (Runs 1-6)

# Start and End index from collision until max height is reached (Runs 1-6)
firstPendulum_dist_pre = Pendulum_dist[0][0:19]
firstPendulum_time_pre = Pendulum_time[0][
    0:19
]  # The indices for the time are going to be same as that of the position

secondPendulum_dist_pre = Pendulum_dist[1][5:24]
secondPendulum_time_pre = Pendulum_time[1][5:24]

thirdPendulum_dist_pre = Pendulum_dist[2][5:16]
thirdPendulum_time_pre = Pendulum_time[2][5:16]

fourthPendulum_dist_pre = Pendulum_dist[3][5:14]
fourthPendulum_time_pre = Pendulum_time[3][5:14]

fifthPendulum_dist_pre = Pendulum_dist[4][5:17]
fifthPendulum_time_pre = Pendulum_time[4][5:17]

sixthPendulum_dist_pre = Pendulum_dist[5][2:14]
sixthPendulum_time_pre = Pendulum_time[5][2:14]

# Making lists to manage cut-off data
Pendulum_time_pre = [
    firstPendulum_time_pre,
    secondPendulum_time_pre,
    thirdPendulum_time_pre,
    fourthPendulum_time_pre,
    fifthPendulum_time_pre,
    sixthPendulum_time_pre,
]
Pendulum_dist_pre = [
    firstPendulum_dist_pre,
    secondPendulum_dist_pre,
    thirdPendulum_dist_pre,
    fourthPendulum_dist_pre,
    fifthPendulum_dist_pre,
    sixthPendulum_dist_pre,
]

# Making maximum height cut offs from the above graphs for Pendulum Cart m2 (Runs 1-6)

# Start and End index from collision until max height is reached (Runs 1-6)
firstPendulum_dist_pre = Pendulum_dist[0][12:27]
firstPendulum_time_pre = Pendulum_time[0][
    12:27
]  # The indices for the time are going to be same as that of the position
firstPendulum_ay_pre = Pendulum_ay[0][12:27]

secondPendulum_dist_pre = Pendulum_dist[1][13:29]
secondPendulum_time_pre = Pendulum_time[1][13:29]
secondPendulum_ay_pre = Pendulum_ay[1][13:29]

thirdPendulum_dist_pre = Pendulum_dist[2][7:22]
thirdPendulum_time_pre = Pendulum_time[2][7:22]
thirdPendulum_ay_pre = Pendulum_ay[2][7:22]

fourthPendulum_dist_pre = Pendulum_dist[3][5:21]
fourthPendulum_time_pre = Pendulum_time[3][5:21]
fourthPendulum_ay_pre = Pendulum_ay[3][5:21]

fifthPendulum_dist_pre = Pendulum_dist[4][9:23]
fifthPendulum_time_pre = Pendulum_time[4][9:23]
fifthPendulum_ay_pre = Pendulum_ay[4][9:23]

sixthPendulum_dist_pre = Pendulum_dist[5][5:20]
sixthPendulum_time_pre = Pendulum_time[5][5:20]
sixthPendulum_ay_pre = Pendulum_ay[5][5:20]

# Making lists to manage cut-off data
Pendulum_time_pre = [
    firstPendulum_time_pre,
    secondPendulum_time_pre,
    thirdPendulum_time_pre,
    fourthPendulum_time_pre,
    fifthPendulum_time_pre,
    sixthPendulum_time_pre,
]
Pendulum_dist_pre = [
    firstPendulum_dist_pre,
    secondPendulum_dist_pre,
    thirdPendulum_dist_pre,
    fourthPendulum_dist_pre,
    fifthPendulum_dist_pre,
    sixthPendulum_dist_pre,
]
Pendulum_ay_pre = [
    firstPendulum_ay_pre,
    secondPendulum_ay_pre,
    thirdPendulum_ay_pre,
    fourthPendulum_ay_pre,
    fifthPendulum_ay_pre,
    sixthPendulum_ay_pre,
]

# Calculating max height for Pendulum Cart m2 (Runs 1-6)


for i in range(len(Pendulum_time_pre)):
    ay = rel_acceleration_in_y(Pendulum_ay_pre[i])
    aA = 2.7  # acceleration due to air resistance #2.7 lowest value that works
    tilt_angle = np.arcsin((ay - aA) / 9.81) - 0.7  # ay=gsin(theta) theta in radians
    print(tilt_angle * 57.2958)
    height = Pendulum_dist_pre[i] * np.cos(tilt_angle)
    print("The maximum height is " + str(np.max(height)) + " m")
    print(
        "Therefore the displaced height is "
        + str(np.max(height) - Pendulum_dist[i][0])
        + " m"
    )
    plt.plot(Pendulum_time_pre[i], height)
    plt.title("Height vs Time for Pendulum (Run " + str(i + 1) + ")")
    plt.xlabel("Time (s)")
    plt.ylabel("Height (m)")
    plt.show()


"""
for i in range(len(Pendulum_time)):
  ay = rel_acceleration_in_y(Pendulum_ay[i])
  aA = 5 # acceleration due to air resistance #2.7 lowest value that works
  tilt_angle = np.arcsin((ay-aA)/9.81) #ay=gsin(theta) theta in radians
  print(tilt_angle * 57.2958)
  height = Pendulum_dist[i]*np.cos(tilt_angle)
  print('The maximum height is ' + str(np.max(height)) + ' m')
  print('Therefore the displaced height is ' + str(np.max(height) - Pendulum_dist[i][0] ) + ' m')
  plt.plot(Pendulum_time[i], height)
  plt.title('Height vs Time for Pendulum (Run ' + str(i+1) + ')')
  plt.xlabel('Time (s)')
  plt.ylabel('Height (m)')
  plt.show()
"""


"""
for i in range(len(Pendulum_time)):
  ax = rel_acceleration_in_x(Pendulum_ax[i])
  print(ax)
  tilt_angle = np.arcsin((ax)/9.81)
  #print(tilt_angle * 57.2958)
  height = Pendulum_dist[i]*np.cos(tilt_angle)
  print('The maximum height is ' + str(np.max(height)) + ' m')
  print('Therefore the displaced height is ' + str(np.max(height) - Pendulum_dist[i][0] ) + ' m')
  plt.plot(Pendulum_time[i], height)
  plt.title('Height vs Time for Pendulum (Run ' + str(i+1) + ')')
  plt.xlabel('Time (s)')
  plt.ylabel('Height (m)')
  plt.show()
  """


"""**END OF FAIR WORK**

---
"""

firstPendulum_dist_pre = Pendulum_dist[0][0:18]
firstPendulum_time_pre = Pendulum_time[0][
    0:18
]  # The indices for the time are going to be same as that of the position
firstPendulum_ay_pre = Pendulum_ay[0][0:18]

secondPendulum_dist_pre = Pendulum_dist[1][7:23]
secondPendulum_time_pre = Pendulum_time[1][7:23]
secondPendulum_ay_pre = Pendulum_ay[1][7:23]

thirdPendulum_dist_pre = Pendulum_dist[2][0:13]
thirdPendulum_time_pre = Pendulum_time[2][0:13]
thirdPendulum_ay_pre = Pendulum_ay[2][0:13]

fourthPendulum_dist_pre = Pendulum_dist[3][5:13]
fourthPendulum_time_pre = Pendulum_time[3][5:13]
fourthPendulum_ay_pre = Pendulum_ay[3][5:13]

fifthPendulum_dist_pre = Pendulum_dist[4][5:17]
fifthPendulum_time_pre = Pendulum_time[4][5:17]
fifthPendulum_ay_pre = Pendulum_ay[4][5:17]

sixthPendulum_dist_pre = Pendulum_dist[5][0:13]
sixthPendulum_time_pre = Pendulum_time[5][0:13]
sixthPendulum_ay_pre = Pendulum_ay[5][0:13]

# Making lists to manage cut-off data
Pendulum_time_pre = [
    firstPendulum_time_pre,
    secondPendulum_time_pre,
    thirdPendulum_time_pre,
    fourthPendulum_time_pre,
    fifthPendulum_time_pre,
    sixthPendulum_time_pre,
]
Pendulum_dist_pre = [
    firstPendulum_dist_pre,
    secondPendulum_dist_pre,
    thirdPendulum_dist_pre,
    fourthPendulum_dist_pre,
    fifthPendulum_dist_pre,
    sixthPendulum_dist_pre,
]
Pendulum_ay_pre = [
    firstPendulum_ay_pre,
    secondPendulum_ay_pre,
    thirdPendulum_ay_pre,
    fourthPendulum_ay_pre,
    fifthPendulum_ay_pre,
    sixthPendulum_ay_pre,
]
